---
# ServiceAccount for scaffolder to deploy services
apiVersion: v1
kind: ServiceAccount
metadata:
  name: scaffolder-deployer
  labels:
    app: scaffolder-service

---
# ClusterRole for scaffolder to deploy services
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: scaffolder-deployer
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["create", "update", "get", "list", "watch"]
- apiGroups: [""]
  resources: ["services", "pods"]
  verbs: ["create", "update", "get", "list", "watch"]
- apiGroups: [""]
  resources: ["pods/log"]
  verbs: ["get", "list"]

---
# ClusterRoleBinding for scaffolder
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: scaffolder-deployer
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: scaffolder-deployer
subjects:
- kind: ServiceAccount
  name: scaffolder-deployer
  namespace: default

---
# Scaffolder Service with GitHub integration
apiVersion: apps/v1
kind: Deployment
metadata:
  name: scaffolder-service
  labels:
    app: scaffolder-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: scaffolder-service
  template:
    metadata:
      labels:
        app: scaffolder-service
    spec:
      serviceAccountName: scaffolder-deployer
      containers:
      - name: scaffolder-service
        image: scaffolder-service:latest
        imagePullPolicy: IfNotPresent
        env:
        - name: GITHUB_TOKEN
          valueFrom:
            secretKeyRef:
              name: github-token
              key: token
        - name: GITHUB_OWNER
          value: "felipeazv"
        - name: PORT
          value: "3000"
        ports:
        - containerPort: 3000
          name: http
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        volumeMounts:
        - name: projects
          mountPath: /projects
        - name: dockersock
          mountPath: /var/run/docker.sock
      volumes:
      - name: projects
        emptyDir: {}
      - name: dockersock
        hostPath:
          path: /var/run/docker.sock
          type: Socket
---
# Old inline script version - keeping for reference, can be deleted
# apiVersion: apps/v1
# kind: Deployment
# metadata:
#   name: scaffolder-service-old
#   labels:
#     app: scaffolder-service-old
# spec:
#   replicas: 1
#   selector:
#     matchLabels:
#       app: scaffolder-service-old
#   template:
#     metadata:
#       labels:
#         app: scaffolder-service-old
#     spec:
#       serviceAccountName: scaffolder-deployer
#       containers:
#       - name: scaffolder-service
#         image: node:18-alpine
#         command: ["/bin/sh"]
#         args:
          - -c
          - |
            apk add --no-cache curl ca-certificates docker-cli && \
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" && \
            chmod +x kubectl && mv kubectl /usr/local/bin/ && \
            curl -LO "https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64" && \
            chmod +x minikube-linux-amd64 && mv minikube-linux-amd64 /usr/local/bin/minikube && \
            mkdir -p /app && cd /app
            cat > package.json <<'EOFPKG'
            {
              "name": "scaffolder-service",
              "version": "1.0.0",
              "description": "Backstage Software Template Scaffolder",
              "main": "server.js",
              "scripts": {
                "start": "node server.js"
              },
              "dependencies": {
                "express": "^4.18.2",
                "cors": "^2.8.5",
                "body-parser": "^1.20.2"
              }
            }
            EOFPKG
            
            npm install --production 2>&1 | tail -20
            
            cat > server.js <<'EOFSERVER'
            const express = require('express');
            const cors = require('cors');
            const bodyParser = require('body-parser');
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            const app = express();
            app.use(cors());
            app.use(bodyParser.json({ limit: '10mb' }));

            const PROJECTS_DIR = '/projects/scaffolded-projects';
            if (!fs.existsSync(PROJECTS_DIR)) {
              fs.mkdirSync(PROJECTS_DIR, { recursive: true });
            }

            app.get('/health', (req, res) => {
              res.json({ status: 'ok', service: 'scaffolder' });
            });

            app.post('/api/scaffold', async (req, res) => {
              try {
                const {
                  component_id,
                  description,
                  owner,
                  port,
                  java_version,
                  include_docker,
                  include_k8s
                } = req.body;

                console.log(`[SCAFFOLD] Creating service: ${component_id}`);

                if (!component_id || !/^[a-z0-9]([a-z0-9-]*[a-z0-9])?$/.test(component_id)) {
                  return res.status(400).json({ 
                    error: 'Invalid component_id' 
                  });
                }

                const projectDir = path.join(PROJECTS_DIR, component_id);
                if (fs.existsSync(projectDir)) {
                  return res.status(409).json({ 
                    error: `Project ${component_id} already exists` 
                  });
                }

                const packageName = `com.example.${component_id.replace(/-/g, '')}`;
                const packagePath = packageName.split('.').join('/');
                const srcDir = path.join(projectDir, 'src', 'main', 'java', packagePath);
                const resourcesDir = path.join(projectDir, 'src', 'main', 'resources');
                const k8sDir = path.join(projectDir, 'k8s');

                [srcDir, resourcesDir, k8sDir].forEach(dir => {
                  fs.mkdirSync(dir, { recursive: true });
                });

                const appClassName = component_id.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('') + 'Application';
                const controllerClassName = appClassName.replace('Application', 'Controller');

                fs.writeFileSync(path.join(projectDir, 'pom.xml'), generatePomXml(component_id, packageName, java_version));
                fs.writeFileSync(path.join(resourcesDir, 'application.properties'), generateApplicationProperties(port));
                fs.writeFileSync(path.join(srcDir, `${appClassName}.java`), generateApplicationClass(packageName, appClassName));
                fs.writeFileSync(path.join(srcDir, `${controllerClassName}.java`), generateController(packageName, controllerClassName, component_id));

                if (include_docker) {
                  fs.writeFileSync(path.join(projectDir, 'Dockerfile'), generateDockerfile(component_id, java_version));
                }

                if (include_k8s) {
                  fs.writeFileSync(path.join(k8sDir, 'deployment.yaml'), generateK8sDeployment(component_id, owner, port));
                  fs.writeFileSync(path.join(k8sDir, 'service.yaml'), generateK8sService(component_id, port));
                }

                fs.writeFileSync(path.join(projectDir, 'catalog-info.yaml'), generateCatalogInfo(component_id, owner, description));
                fs.writeFileSync(path.join(projectDir, 'README.md'), generateReadme(component_id, description, port));
                fs.writeFileSync(path.join(projectDir, '.gitignore'), generateGitignore());

                console.log(`[SUCCESS] Project created: ${projectDir}`);

                res.json({
                  success: true,
                  message: `Service ${component_id} scaffolded successfully`,
                  projectPath: projectDir,
                  localPath: `/Users/felipeazevedo/Projects/scaffolded-projects/${component_id}`,
                  files: {
                    pom: `${component_id}/pom.xml`,
                    dockerfile: `${component_id}/Dockerfile`,
                    k8s: [
                      `${component_id}/k8s/deployment.yaml`,
                      `${component_id}/k8s/service.yaml`
                    ],
                    source: [
                      `${component_id}/src/main/java/${packagePath}/${appClassName}.java`,
                      `${component_id}/src/main/java/${packagePath}/${controllerClassName}.java`
                    ]
                  }
                });
              } catch (error) {
                console.error('[ERROR]', error);
                res.status(500).json({ error: error.message });
              }
            });

            function generatePomXml(serviceName, packageName, javaVersion) {
              return `<?xml version="1.0" encoding="UTF-8"?>
            <project xmlns="http://maven.apache.org/POM/4.0.0">
                <modelVersion>4.0.0</modelVersion>
                <groupId>com.example</groupId>
                <artifactId>${serviceName}</artifactId>
                <version>1.0.0</version>
                <packaging>jar</packaging>
                <name>${serviceName}</name>
                <parent>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-parent</artifactId>
                    <version>3.2.1</version>
                </parent>
                <properties>
                    <java.version>${javaVersion}</java.version>
                </properties>
                <dependencies>
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-web</artifactId>
                    </dependency>
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-actuator</artifactId>
                    </dependency>
                    <dependency>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-test</artifactId>
                        <scope>test</scope>
                    </dependency>
                </dependencies>
                <build>
                    <plugins>
                        <plugin>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-maven-plugin</artifactId>
                        </plugin>
                    </plugins>
                </build>
            </project>`;
            }

            function generateApplicationProperties(port) {
              return `server.port=${port}\nspring.application.name=spring-boot-service\nmanagement.endpoints.web.exposure.include=health,info\n`;
            }

            function generateApplicationClass(packageName, className) {
              return `package ${packageName};
            import org.springframework.boot.SpringApplication;
            import org.springframework.boot.autoconfigure.SpringBootApplication;
            @SpringBootApplication
            public class ${className} {
                public static void main(String[] args) {
                    SpringApplication.run(${className}.class, args);
                }
            }`;
            }

            function generateController(packageName, className, serviceName) {
              return `package ${packageName};
            import org.springframework.web.bind.annotation.GetMapping;
            import org.springframework.web.bind.annotation.RestController;
            @RestController
            public class ${className} {
                @GetMapping("/")
                public java.util.Map<String, String> root() {
                    java.util.Map<String, String> r = new java.util.HashMap<>();
                    r.put("service", "${serviceName}");
                    r.put("status", "running");
                    return r;
                }
                @GetMapping("/health")
                public java.util.Map<String, String> health() {
                    java.util.Map<String, String> r = new java.util.HashMap<>();
                    r.put("status", "UP");
                    return r;
                }
            }`;
            }

            function generateDockerfile(serviceName, javaVersion) {
              return `FROM eclipse-temurin:${javaVersion}-jdk-alpine AS builder
            WORKDIR /build
            COPY . .
            RUN apk add --no-cache maven && mvn clean package -DskipTests
            FROM eclipse-temurin:${javaVersion}-jre-alpine
            WORKDIR /app
            COPY --from=builder /build/target/*.jar app.jar
            EXPOSE 8080
            CMD ["java", "-jar", "app.jar"]`;
            }

            function generateK8sDeployment(serviceName, owner, port) {
              return `apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: ${serviceName}
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: ${serviceName}
              template:
                metadata:
                  labels:
                    app: ${serviceName}
                spec:
                  containers:
                  - name: ${serviceName}
                    image: ${serviceName}:latest
                    imagePullPolicy: Never
                    ports:
                    - containerPort: ${port}
                    livenessProbe:
                      httpGet:
                        path: /health
                        port: ${port}
                      initialDelaySeconds: 30
                    readinessProbe:
                      httpGet:
                        path: /health
                        port: ${port}
                      initialDelaySeconds: 15`;
            }

            function generateK8sService(serviceName, port) {
              return `apiVersion: v1
            kind: Service
            metadata:
              name: ${serviceName}-service
            spec:
              type: NodePort
              ports:
              - port: ${port}
                targetPort: ${port}
              selector:
                app: ${serviceName}`;
            }

            function generateCatalogInfo(serviceName, owner, description) {
              return `apiVersion: backstage.io/v1alpha1
            kind: Component
            metadata:
              name: ${serviceName}
            spec:
              type: service
              owner: ${owner}
              lifecycle: production`;
            }

            function generateReadme(serviceName, description, port) {
              return `# ${serviceName}\n${description}\nPort: ${port}`;
            }

            function generateGitignore() {
              return `target/\n.idea/\n.vscode/\nnode_modules/`;
            }

            app.get('/download/:projectId', (req, res) => {
              const { projectId } = req.params;
              const projectPath = path.join(PROJECTS_DIR, projectId);
              
              if (!fs.existsSync(projectPath)) {
                return res.status(404).json({ error: 'Project not found' });
              }
              
              try {
                const tarFile = `/tmp/${projectId}.tar.gz`;
                execSync(`cd ${PROJECTS_DIR} && tar czf ${tarFile} ${projectId}`);
                res.download(tarFile, `${projectId}.tar.gz`, (err) => {
                  if (!err) {
                    try { fs.unlinkSync(tarFile); } catch(e) {}
                  }
                });
              } catch (error) {
                res.status(500).json({ error: error.message });
              }
            });

            app.get('/api/deploy/:projectId/stream', (req, res) => {
              const { projectId } = req.params;
              const { port } = req.query;
              const servicePort = parseInt(port) || 8080;
              const projectPath = path.join(PROJECTS_DIR, projectId);
              const k8sDir = path.join(projectPath, 'k8s');
              
              // Set up Server-Sent Events
              res.setHeader('Content-Type', 'text/event-stream');
              res.setHeader('Cache-Control', 'no-cache');
              res.setHeader('Connection', 'keep-alive');
              res.setHeader('Access-Control-Allow-Origin', '*');
              
              const sendLog = (message) => {
                try {
                  res.write(`data: ${JSON.stringify({ log: message })}\n\n`);
                } catch (e) {
                  console.error('[SEND_LOG_ERROR]', e.message);
                }
              };
              
              const sendError = (message) => {
                try {
                  res.write(`data: ${JSON.stringify({ error: message })}\n\n`);
                  res.end();
                } catch (e) {
                  console.error('[SEND_ERROR_ERROR]', e.message);
                }
              };
              
              const sendSuccess = (data) => {
                try {
                  res.write(`data: ${JSON.stringify({ success: true, ...data })}\n\n`);
                  res.end();
                } catch (e) {
                  console.error('[SEND_SUCCESS_ERROR]', e.message);
                }
              };
              
              if (!fs.existsSync(k8sDir)) {
                sendError('K8s manifests not found');
                return;
              }
              
              try {
                const deploymentFile = path.join(k8sDir, 'deployment.yaml');
                const serviceFile = path.join(k8sDir, 'service.yaml');
                
                if (!fs.existsSync(deploymentFile) || !fs.existsSync(serviceFile)) {
                  sendError('Missing deployment or service manifest');
                  return;
                }
                
                sendLog(`üöÄ Starting deployment for ${projectId}...`);
                sendLog(`üìÅ Project path: ${projectPath}`);
                sendLog('');
                
                // Build Docker image using minikube's Docker daemon
                sendLog('üê≥ Building Docker image in minikube...');
                sendLog('(This may take 2-3 minutes for first build - Maven dependencies)');
                sendLog('');
                try {
                  // Build using Docker directly (socket is mounted from minikube's daemon)
                  const buildCmd = `cd ${projectPath} && docker build -t ${projectId}:latest .`;
                  const buildOutput = execSync(buildCmd, { 
                    encoding: 'utf-8',
                    maxBuffer: 20 * 1024 * 1024
                  });
                  
                  // Show last few lines of build output
                  const lines = buildOutput.split('\\n').filter(l => l.trim());
                  const lastLines = lines.slice(-10);
                  lastLines.forEach(line => sendLog(`   ${line}`));
                  
                  sendLog('');
                  sendLog(`‚úÖ Image built successfully: ${projectId}:latest`);
                  sendLog('‚úÖ Image available in minikube Docker daemon');
                } catch (e) {
                  const errorMsg = e.message || e.toString();
                  sendLog('');
                  sendLog('‚ùå Build failed:');
                  const errorLines = errorMsg.split('\\n').slice(0, 20);
                  errorLines.forEach(line => {
                    if (line.trim()) sendLog(`   ${line}`);
                  });
                  sendError('Docker build failed. Check logs above for details.');
                  return;
                }
                
                sendLog('');
                
                // Apply service
                sendLog('üì¶ Applying Kubernetes Service...');
                try {
                  const svcOutput = execSync(`kubectl apply -f ${serviceFile}`, { encoding: 'utf-8' });
                  sendLog(`‚úÖ ${svcOutput.trim()}`);
                } catch (e) {
                  sendLog(`‚ö†Ô∏è  Service: ${e.message}`);
                }
                
                sendLog('');
                
                // Apply deployment
                sendLog('üîß Applying Kubernetes Deployment...');
                try {
                  const depOutput = execSync(`kubectl apply -f ${deploymentFile}`, { encoding: 'utf-8' });
                  sendLog(`‚úÖ ${depOutput.trim()}`);
                } catch (e) {
                  sendLog(`‚ö†Ô∏è  Deployment: ${e.message}`);
                }
                
                sendLog('');
                sendLog('‚è≥ Waiting for pods to start...');
                
                // Wait a moment and check pod status
                setTimeout(() => {
                  try {
                    const pods = execSync(`kubectl get pods -l app=${projectId} --no-headers`, { encoding: 'utf-8' });
                    if (pods.trim()) {
                      sendLog('üìã Pod status:');
                      pods.trim().split('\n').forEach(pod => sendLog(`   ${pod}`));
                    } else {
                      sendLog('‚ö†Ô∏è  No pods found yet (may take a moment)');
                    }
                  } catch (e) {
                    sendLog(`‚ö†Ô∏è  Could not get pod status: ${e.message}`);
                  }
                  
                  sendLog('');
                  sendLog('üéâ Deployment complete!');
                  sendLog('');
                  sendLog('üìù Next steps:');
                  sendLog(`   kubectl get pods -l app=${projectId}`);
                  sendLog(`   kubectl logs -l app=${projectId} -f`);
                  sendLog(`   kubectl get svc ${projectId}-service`);
                  sendLog('');
                  sendLog('üß™ To test the service:');
                  sendLog(`   kubectl port-forward svc/${projectId}-service ${servicePort}:${servicePort}`);
                  sendLog(`   curl http://localhost:${servicePort}/hello`);
                  
                  sendSuccess({
                    message: `Service ${projectId} deployed to Kubernetes`,
                    projectId: projectId,
                    deployment: {
                      name: projectId,
                      replicas: 2,
                      namespace: 'default'
                    }
                  });
                }, 2000);
                
              } catch (error) {
                console.error('[DEPLOY ERROR]', error);
                sendError(error.message);
              }
            });

            const PORT = 3000;
            app.listen(PORT, '0.0.0.0', () => {
              console.log(`Scaffolder listening on port ${PORT}`);
            });
            EOFSERVER

            node server.js
        ports:
        - containerPort: 3000
          name: http
        volumeMounts:
        - name: projects-volume
          mountPath: /projects/scaffolded-projects
        - name: docker-socket
          mountPath: /var/run/docker.sock
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: projects-volume
        hostPath:
          path: /tmp/minikube-projects
          type: DirectoryOrCreate
      - name: docker-socket
        hostPath:
          path: /var/run/docker.sock
          type: Socket

---
apiVersion: v1
kind: Service
metadata:
  name: scaffolder-service
  labels:
    app: scaffolder-service
spec:
  type: NodePort
  ports:
  - port: 3000
    targetPort: 3000
    nodePort: 30300
    protocol: TCP
    name: http
  selector:
    app: scaffolder-service

---
# Backstage UI Service (unchanged)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backstage
  labels:
    app: backstage
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backstage
  template:
    metadata:
      labels:
        app: backstage
    spec:
      containers:
      - name: backstage
        image: node:18
        command: ["/bin/sh"]
        args:
          - -c
          - |
            npm install -g http-server
            mkdir -p /app/public
            cd /app
            cat > public/index.html <<'EOFHTML'
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Backstage Developer Portal</title>
                <style>
                    * { margin: 0; padding: 0; box-sizing: border-box; }
                    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto; background: linear-gradient(135deg, #1a237e 0%, #283593 100%); min-height: 100vh; }
                    header { background: rgba(0, 0, 0, 0.7); color: white; padding: 20px 40px; border-bottom: 3px solid #1976d2; }
                    header h1 { font-size: 28px; margin-bottom: 5px; }
                    .container { max-width: 1200px; margin: 40px auto; padding: 0 20px; }
                    .content-section { background: white; border-radius: 8px; padding: 40px; margin-bottom: 30px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }
                    h2 { color: #1976d2; margin-bottom: 20px; font-size: 24px; border-bottom: 2px solid #90caf9; padding-bottom: 10px; }
                    .form-group { margin-bottom: 20px; }
                    label { display: block; margin-bottom: 8px; font-weight: 600; color: #333; }
                    input, select, textarea { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-family: inherit; }
                    input:focus, select:focus, textarea:focus { outline: none; border-color: #1976d2; box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1); }
                    button { background: #1976d2; color: white; padding: 12px 30px; border: none; border-radius: 6px; cursor: pointer; }
                    button:hover { background: #1565c0; }
                    .alert { padding: 15px; margin: 20px 0; border-radius: 6px; border-left: 4px solid #2196f3; }
                    .alert.success { border-color: #4caf50; background: #e8f5e9; color: #2e7d32; }
                    .alert.error { border-color: #f44336; background: #ffebee; color: #c62828; }
                    .alert.loading { border-color: #2196f3; background: #e3f2fd; color: #1565c0; }
                    .form-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
                    .response { background: #f5f5f5; padding: 15px; border-radius: 6px; margin-top: 20px; white-space: pre-wrap; overflow-x: auto; font-family: monospace; font-size: 12px; }
                    .info-box { background: #e3f2fd; padding: 15px; border-radius: 6px; margin-top: 15px; border-left: 4px solid #2196f3; }
                    footer { text-align: center; padding: 20px; color: white; opacity: 0.8; }
                </style>
            </head>
            <body>
                <header>
                    <h1>üé≠ Backstage Developer Portal</h1>
                    <p>Automated Spring Boot Service Scaffolding on Minikube</p>
                </header>

                <div class="container">
                    <div class="content-section">
                        <h2>üöÄ Create New Spring Boot Service</h2>
                        <p style="color: #666; margin-bottom: 20px;">Generate a complete Spring Boot microservice with Docker and Kubernetes support. Files are automatically saved to your local computer.</p>
                        
                        <form id="scaffoldForm">
                            <h3 style="color: #1976d2; margin: 20px 0 15px;">Project Information</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="component_id">Service Name *</label>
                                    <input type="text" id="component_id" name="component_id" placeholder="e.g., user-service" required>
                                </div>
                                <div class="form-group">
                                    <label for="owner">Owner *</label>
                                    <input type="text" id="owner" name="owner" placeholder="e.g., platform-team" required>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="description">Description</label>
                                <textarea id="description" name="description" rows="2" placeholder="Service description">A Spring Boot microservice</textarea>
                            </div>

                            <h3 style="color: #1976d2; margin: 30px 0 15px;">Deployment Configuration</h3>
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="port">Server Port</label>
                                    <input type="number" id="port" name="port" value="8080" min="1024" max="65535">
                                </div>
                                <div class="form-group">
                                    <label for="java_version">Java Version</label>
                                    <select id="java_version" name="java_version">
                                        <option value="11">Java 11</option>
                                        <option value="17">Java 17</option>
                                        <option value="21" selected>Java 21</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-row">
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" id="include_docker" name="include_docker" checked style="width: auto; margin-right: 10px;">
                                    Include Docker support
                                </label>
                                <label style="display: flex; align-items: center;">
                                    <input type="checkbox" id="include_k8s" name="include_k8s" checked style="width: auto; margin-right: 10px;">
                                    Include Kubernetes manifests
                                </label>
                            </div>

                            <button type="submit" id="submitBtn">üìã Generate Service</button>
                            <button type="button" id="downloadBtn" style="margin-left: 10px; background: #4caf50; display: none;">‚¨áÔ∏è Download Project</button>
                            <button type="button" id="deployBtn" style="margin-left: 10px; background: #ff9800; display: none;">üöÄ Deploy to Kubernetes</button>
                            <button type="button" id="cleanupBtn" style="margin-left: 10px; background: #f44336; display: none;">üóëÔ∏è Clean Up Service</button>
                            <button type="button" id="cleanupAllBtn" style="margin-left: 10px; background: #d32f2f;">üóëÔ∏è Delete All Services</button>
                        </form>

                        <div id="message" style="display: none;"></div>
                        <div id="response"></div>
                    </div>
                </div>

                <footer>
                    <p>üé≠ Backstage Developer Portal | Minikube Integration</p>
                </footer>

                <script>
                    let lastServiceName = '';
                    let lastServicePort = 8080;
                    const apiHost = location.hostname || 'localhost';

                    document.getElementById('scaffoldForm').addEventListener('submit', async (e) => {
                        e.preventDefault();
                        
                        const formData = {
                            component_id: document.getElementById('component_id').value,
                            description: document.getElementById('description').value,
                            owner: document.getElementById('owner').value,
                            port: parseInt(document.getElementById('port').value),
                            java_version: document.getElementById('java_version').value,
                            include_docker: document.getElementById('include_docker').checked,
                            include_k8s: document.getElementById('include_k8s').checked
                        };

                        if (!/^[a-z0-9]([a-z0-9-]*[a-z0-9])?$/.test(formData.component_id)) {
                            showMessage('Service name must be lowercase alphanumeric with hyphens', 'error');
                            return;
                        }

                        showMessage('Scaffolding in progress...', 'loading');
                        document.getElementById('submitBtn').disabled = true;

                        try {
                            const apiUrl = `http://${apiHost}:30300/api/scaffold`;
                            const response = await fetch(apiUrl, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(formData)
                            });

                            const _text = await response.text();
                            let result;
                            try { result = JSON.parse(_text); } catch (e) { result = { error: _text }; }

                            if (response.ok) {
                              lastServiceName = formData.component_id;
                              lastServicePort = formData.port;
                                showMessage(`‚úÖ Service created: ${formData.component_id}`, 'success');
                                const infoBox = `<div class="info-box"><strong>üìÅ Local Path:</strong><br/><code>${result.localPath}</code><br/><br/><strong>Next steps:</strong><br/>1. Deploy to Kubernetes (button below)<br/>2. Or download and deploy manually<br/>3. Then: kubectl logs -l app=${formData.component_id}</div>`;
                                showResponse(JSON.stringify(result, null, 2) + infoBox);
                                document.getElementById('downloadBtn').style.display = 'inline-block';
                                document.getElementById('deployBtn').style.display = 'inline-block';
                                document.getElementById('cleanupBtn').style.display = 'inline-block';
                                document.getElementById('scaffoldForm').reset();
                            } else {
                                showMessage(`‚ùå Error: ${result.error}`, 'error');
                                document.getElementById('downloadBtn').style.display = 'none';
                                document.getElementById('deployBtn').style.display = 'none';
                                document.getElementById('cleanupBtn').style.display = 'none';
                            }
                        } catch (error) {
                            showMessage(`‚ùå Connection error: ${error.message}`, 'error');
                            document.getElementById('downloadBtn').style.display = 'none';
                        } finally {
                            document.getElementById('submitBtn').disabled = false;
                        }
                    });

                    document.getElementById('downloadBtn').addEventListener('click', async () => {
                        if (!lastServiceName) {
                            showMessage('No service to download', 'error');
                            return;
                        }
                        
                        try {
                            const response = await fetch(`http://${apiHost}:30300/download/${lastServiceName}`);
                            if (response.ok) {
                                const blob = await response.blob();
                                const url = window.URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `${lastServiceName}.tar.gz`;
                                document.body.appendChild(a);
                                a.click();
                                window.URL.revokeObjectURL(url);
                                a.remove();
                                showMessage(`‚úÖ Downloaded ${lastServiceName}.tar.gz`, 'success');
                            } else {
                                showMessage('Failed to download project', 'error');
                            }
                        } catch (error) {
                            showMessage(`Error downloading: ${error.message}`, 'error');
                        }
                    });

                    document.getElementById('deployBtn').addEventListener('click', async () => {
                        if (!lastServiceName) {
                            showMessage('No service to deploy', 'error');
                            return;
                        }
                        
                        showMessage('üöÄ Starting deployment...', 'loading');
                        document.getElementById('deployBtn').disabled = true;
                        
                        // Clear previous logs
                        const logsDiv = document.createElement('div');
                        logsDiv.className = 'response';
                        logsDiv.style.background = '#1e1e1e';
                        logsDiv.style.color = '#00ff00';
                        logsDiv.style.fontFamily = 'monospace';
                        logsDiv.style.padding = '15px';
                        logsDiv.style.borderRadius = '6px';
                        logsDiv.style.marginTop = '15px';
                        logsDiv.style.maxHeight = '400px';
                        logsDiv.style.overflowY = 'auto';
                        logsDiv.innerHTML = '<div style="color: #00ff00;">üì° Connecting to deployment stream...</div>';
                        document.getElementById('response').innerHTML = '';
                        document.getElementById('response').appendChild(logsDiv);
                        
                        try {
                            const eventSource = new EventSource(`http://${apiHost}:30300/api/deploy/${lastServiceName}/stream?port=${lastServicePort}`);
                            
                            eventSource.onmessage = (event) => {
                                const data = JSON.parse(event.data);
                                
                                if (data.error) {
                                    logsDiv.innerHTML += `<div style="color: #ff4444;">‚ùå Error: ${data.error}</div>`;
                                    showMessage(`‚ùå Deployment failed: ${data.error}`, 'error');
                                    eventSource.close();
                                    document.getElementById('deployBtn').disabled = false;
                                } else if (data.success) {
                                    showMessage(`‚úÖ Service deployed: ${lastServiceName}`, 'success');
                                    eventSource.close();
                                    document.getElementById('deployBtn').disabled = false;
                                } else if (data.log) {
                                    // Color code different log types
                                    let color = '#00ff00';
                                    if (data.log.includes('‚ùå') || data.log.includes('‚ö†Ô∏è')) color = '#ffaa00';
                                    if (data.log.includes('‚úÖ')) color = '#00ff88';
                                    if (data.log.includes('üöÄ') || data.log.includes('üéâ')) color = '#00aaff';
                                    
                                    logsDiv.innerHTML += `<div style="color: ${color};">${data.log}</div>`;
                                    logsDiv.scrollTop = logsDiv.scrollHeight;
                                }
                            };
                            
                            eventSource.onerror = (error) => {
                                logsDiv.innerHTML += `<div style="color: #ff4444;">‚ùå Connection error</div>`;
                                showMessage('‚ùå Deployment stream disconnected', 'error');
                                eventSource.close();
                                document.getElementById('deployBtn').disabled = false;
                            };
                            
                        } catch (error) {
                            showMessage(`Error deploying: ${error.message}`, 'error');
                            document.getElementById('deployBtn').disabled = false;
                        }
                    });

                    document.getElementById('cleanupBtn').addEventListener('click', async () => {
                        if (!lastServiceName) {
                            showMessage('No service to clean up', 'error');
                            return;
                        }
                        
                        if (!confirm(`Are you sure you want to delete ${lastServiceName}? This will remove:\n- GitHub repository\n- Kubernetes deployment and service\n- Local storage`)) {
                            return;
                        }
                        
                        showMessage(`üóëÔ∏è Cleaning up ${lastServiceName}...`, 'loading');
                        document.getElementById('cleanupBtn').disabled = true;
                        
                        try {
                            const response = await fetch(`http://${apiHost}:30300/api/cleanup/${lastServiceName}`, {
                                method: 'DELETE'
                            });
                            
                            const _text = await response.text();
                            let result;
                            try { result = JSON.parse(_text); } catch (e) { result = { error: _text }; }

                            if (response.ok) {
                              showMessage(`‚úÖ Successfully deleted ${lastServiceName}`, 'success');
                              showResponse(JSON.stringify(result, null, 2));
                                document.getElementById('cleanupBtn').style.display = 'none';
                                document.getElementById('downloadBtn').style.display = 'none';
                                document.getElementById('deployBtn').style.display = 'none';
                                lastServiceName = '';
                            } else {
                                showMessage(`‚ùå Error: ${result.error}`, 'error');
                            }
                        } catch (error) {
                            showMessage(`Error cleaning up: ${error.message}`, 'error');
                        } finally {
                            document.getElementById('cleanupBtn').disabled = false;
                        }
                    });

                    document.getElementById('cleanupAllBtn').addEventListener('click', async () => {
                        if (!confirm('‚ö†Ô∏è WARNING: This will delete ALL scaffolded services including:\n- All GitHub repositories\n- All Kubernetes deployments and services\n- All local storage\n\nThis action cannot be undone. Continue?')) {
                            return;
                        }
                        
                        showMessage('üóëÔ∏è Deleting all services...', 'loading');
                        document.getElementById('cleanupAllBtn').disabled = true;
                        
                        try {
                            const response = await fetch(`http://${apiHost}:30300/api/cleanup-all`, {
                                method: 'DELETE'
                            });
                            
                            const _text = await response.text();
                            let result;
                            try { result = JSON.parse(_text); } catch (e) { result = { error: _text }; }

                            if (response.ok) {
                              showMessage(`‚úÖ Successfully deleted all services`, 'success');
                              showResponse(JSON.stringify(result, null, 2));
                                document.getElementById('cleanupBtn').style.display = 'none';
                                document.getElementById('downloadBtn').style.display = 'none';
                                document.getElementById('deployBtn').style.display = 'none';
                                lastServiceName = '';
                            } else {
                                showMessage(`‚ùå Error: ${result.error}`, 'error');
                            }
                        } catch (error) {
                            showMessage(`Error cleaning up all services: ${error.message}`, 'error');
                        } finally {
                            document.getElementById('cleanupAllBtn').disabled = false;
                        }
                    });

                    function showMessage(msg, type) {
                        const msgDiv = document.getElementById('message');
                        msgDiv.innerHTML = `<div class="alert ${type}">${msg}</div>`;
                        msgDiv.style.display = 'block';
                    }

                    function showResponse(content) {
                        document.getElementById('response').innerHTML = `<div class="response">${content}</div>`;
                    }
                </script>
            </body>
            </html>
            EOFHTML
            http-server ./public -p 7000
        ports:
        - containerPort: 7000
          name: http
        livenessProbe:
          httpGet:
            path: /
            port: 7000
          initialDelaySeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 7000
          initialDelaySeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: backstage-service
  labels:
    app: backstage
spec:
  type: NodePort
  ports:
  - port: 7000
    targetPort: 7000
    nodePort: 30700
    name: http
  selector:
    app: backstage
